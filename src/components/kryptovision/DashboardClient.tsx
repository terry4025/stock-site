"use client";

import { useState, useEffect, Suspense, useRef } from "react";
import { getAiAnalysis, getNewsSentiment, getRealtimeFearGreedIndex, getHeadlines, getStockAndChartData, getStockSpecificNews, getMarketNews, startAutoNewsUpdate, getDynamicDateStatus, manualCheckForNewNews } from "@/app/actions";
import { useLanguage } from "@/hooks/useLanguage";
import { useAuth } from "@/contexts/AuthContext";
import { type StockData, type NewsArticle, type ChartData, type ChartDataPoint } from "@/lib/types";
import { initializeUserData, applyUserSettings, updateLoginActivity, startUserSession } from "@/lib/user-menu-helpers";

import Header from "@/components/kryptovision/Header";
import StockSearch from "@/components/kryptovision/StockSearch";
import GlobalIndices from "@/components/kryptovision/GlobalIndices";
import FinancialChart from "@/components/kryptovision/FinancialChart";
import StockDataTable from "@/components/kryptovision/StockDataTable";
import AiAnalysis from "@/components/kryptovision/AiAnalysis";
import NewsCards from "@/components/kryptovision/NewsCards";
import SidebarInfo from "@/components/kryptovision/SidebarInfo";
import FearGreedIndex from "@/components/kryptovision/FearGreedIndex";
import RealtimeStatus from "@/components/kryptovision/RealtimeStatus";
import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";
import { Terminal } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { mockChartData, mockStockData, mockNewsData } from "@/lib/mock-data";
import LoadingScreen from "./LoadingScreen";

export default function DashboardClient({ initialData }: { initialData: any }) {
  const { t, language, setLanguage } = useLanguage();
  const { user } = useAuth();
  
  const [isAppLoading, setIsAppLoading] = useState(true);
  const [ticker, setTicker] = useState("TSLA");
  const [stockData, setStockData] = useState<StockData | null>(initialData.stockData);
  const [chartData, setChartData] = useState<ChartData>(initialData.chartData);
  const [newsData, setNewsData] = useState<NewsArticle[]>(initialData.newsData);
  const [marketNews, setMarketNews] = useState<NewsArticle[]>(initialData.marketNews);
  const [aiAnalysis, setAiAnalysis] = useState<any>(null);
  const [newsSentiment, setNewsSentiment] = useState<any>(null);
  const [fearGreedIndex, setFearGreedIndex] = useState<number | null>(initialData.fearGreedIndex);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(initialData.error);
  const [loadingAnalysis, setLoadingAnalysis] = useState(false);
  const [loadingSentiment, setLoadingSentiment] = useState(false);
  const [loadingNews, setLoadingNews] = useState(false);
  const [analysisStarted, setAnalysisStarted] = useState(false);
  const [isRealtimeEnabled, setIsRealtimeEnabled] = useState(true);
  const [lastUpdateTime, setLastUpdateTime] = useState<Date | null>(null);
  const [refreshInterval, setRefreshInterval] = useState(30); // Í∏∞Î≥∏ 30Ï¥à
  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(true); // ÏûêÎèô ÏÉàÎ°úÍ≥†Ïπ® ÏÑ§Ï†ï
  const isInitialMount = useRef(true);

  // Set initial language from server
  useEffect(() => {
    if (initialData.language) {
      setLanguage(initialData.language);
    }
  }, [initialData.language, setLanguage]);

  // üöÄ Ïï± Ï¥àÍ∏∞Ìôî Î∞è ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  useEffect(() => {
    const initializeApp = async () => {
      try {
        console.log('üöÄ [DashboardClient] Starting app initialization...');
        
        // ÏµúÏÜå Î°úÎî© ÏãúÍ∞Ñ Î≥¥Ïû• (UX Í∞úÏÑ†)
        const minLoadingPromise = new Promise(resolve => setTimeout(resolve, 2000));
        
        // ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÎêòÏñ¥ ÏûàÏúºÎ©¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        let userDataPromise = Promise.resolve();
        if (user?.id) {
          console.log('üë§ [DashboardClient] User logged in, initializing user data...');
          userDataPromise = initializeUserData(user.id).then(userData => {
            console.log('üìä [DashboardClient] User data loaded:', userData);
            
            // ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï Ï†ÅÏö©
            if (userData.settings) {
              applyUserSettings(userData.settings);
              
              // Ïñ∏Ïñ¥ ÏÑ§Ï†ïÏù¥ ÏûàÏúºÎ©¥ Ï†ÅÏö©
              if (userData.settings.language && (userData.settings.language === 'kr' || userData.settings.language === 'en')) {
                setLanguage(userData.settings.language as 'en' | 'kr');
              }
            }
            
            // Î°úÍ∑∏Ïù∏ ÌôúÎèô ÏóÖÎç∞Ïù¥Ìä∏
            updateLoginActivity(user.id);
            
            // ÏÑ∏ÏÖò ÏãúÏûë
            startUserSession(user.id);
          }).catch(err => {
            console.warn('‚ö†Ô∏è [DashboardClient] Failed to load user data:', err);
          });
        }
        
        // üöÄ ÏûêÎèô Îâ¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏä§ÌÖú ÏãúÏûë (ÌÉÄÏûÑÏïÑÏõÉ ÏóêÎü¨ ÏàòÏ†ï)
        console.log('üì∞ [DashboardClient] Starting auto news update system...');
        try {
          const autoUpdateResult = await startAutoNewsUpdate();
          console.log('üì∞ [DashboardClient] Auto news update result:', autoUpdateResult);
        } catch (autoUpdateError) {
          console.warn('‚ö†Ô∏è [DashboardClient] Auto news update failed:', autoUpdateError);
          // ÏóêÎü¨Í∞Ä ÏûàÏñ¥ÎèÑ Ïï± Ï¥àÍ∏∞ÌôîÎäî Í≥ÑÏÜç
        }
        
        // Î™®Îì† Ï¥àÍ∏∞Ìôî ÏûëÏóÖ ÏôÑÎ£å ÎåÄÍ∏∞
        await Promise.all([minLoadingPromise, userDataPromise]);
        
        console.log('‚úÖ [DashboardClient] App initialization completed');
        setIsAppLoading(false);
        
      } catch (error) {
        console.error('‚ùå [DashboardClient] Error during app initialization:', error);
        // ÏóêÎü¨Í∞Ä ÏûàÏñ¥ÎèÑ Î°úÎî©ÏùÄ ÏôÑÎ£å
        setIsAppLoading(false);
      }
    };

    initializeApp();
  }, [user?.id, setLanguage]);

  // üì∞ ÏÉàÎ°úÏö¥ Îâ¥Ïä§ Í∞êÏßÄ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§Îãù (ÏûêÎèô Îâ¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏)
  useEffect(() => {
    const handleNewMarketNews = async (event: Event) => {
      const customEvent = event as CustomEvent;
      const { date, articles } = customEvent.detail;
      console.log(`üì∞ [DashboardClient] New market news detected for ${date}:`, articles?.length || 0, 'articles');
      
      try {
        // ÎßàÏºì Îâ¥Ïä§ ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
        console.log('üì∞ [DashboardClient] Auto-refreshing market news...');
        const freshMarketNews = await getMarketNews(language);
        setMarketNews(freshMarketNews);
        
        // Ï£ºÏãùÎ≥Ñ Îâ¥Ïä§ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ (ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ï¢ÖÎ™©)
        if (ticker) {
          console.log(`üì∞ [DashboardClient] Auto-refreshing ${ticker} specific news...`);
          const freshStockNews = await getStockSpecificNews(ticker, language);
          setNewsData(freshStockNews);
        }
        
        console.log('üì∞ [DashboardClient] News auto-refresh completed');
        
        // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º (ÏòµÏÖò)
        if (typeof window !== 'undefined') {
          // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶ºÏù¥ÎÇò ÌÜ†Ïä§Ìä∏ Î©îÏãúÏßÄÎ°ú ÏÉàÎ°úÏö¥ Îâ¥Ïä§ ÏïåÎ¶º Í∞ÄÎä•
          console.log('üîî [DashboardClient] New market news available!');
        }
        
      } catch (error) {
        console.error('‚ùå [DashboardClient] Failed to auto-refresh news:', error);
      }
    };

    // ÏÉàÎ°úÏö¥ Îâ¥Ïä§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
    window.addEventListener('newMarketNewsAvailable', handleNewMarketNews);

    return () => {
      window.removeEventListener('newMarketNewsAvailable', handleNewMarketNews);
    };
  }, [language, ticker]);

  // üîÑ ÏÑ§Ï†ï Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏ Î¶¨Ïä§Îãù (ÏÉàÎ°úÍ≥†Ïπ® Í∞ÑÍ≤© ÏóÖÎç∞Ïù¥Ìä∏)
  useEffect(() => {
    const handleRefreshIntervalChange = (event: CustomEvent) => {
      const { interval, auto_refresh } = event.detail;
      console.log(`üîÑ [DashboardClient] Settings changed - Interval: ${interval} seconds, Auto refresh: ${auto_refresh}`);
      
      if (interval !== undefined) {
        setRefreshInterval(interval);
      }
      
      if (auto_refresh !== undefined) {
        setAutoRefreshEnabled(auto_refresh);
        setIsRealtimeEnabled(auto_refresh);
      }
    };

    window.addEventListener('refreshIntervalChanged', handleRefreshIntervalChange as EventListener);

    // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Ï¥àÍ∏∞ ÏÑ§Ï†ï Î°úÎìú
    const savedSettings = localStorage.getItem('kryptovision_user_settings');
    if (savedSettings) {
      try {
        const settings = JSON.parse(savedSettings);
        if (settings.settings?.refresh_interval) {
          console.log(`üîÑ [DashboardClient] Initial refresh interval from localStorage: ${settings.settings.refresh_interval} seconds`);
          setRefreshInterval(settings.settings.refresh_interval);
        }
        if (settings.settings?.auto_refresh !== undefined) {
          console.log(`üîÑ [DashboardClient] Initial auto refresh from localStorage: ${settings.settings.auto_refresh}`);
          setAutoRefreshEnabled(settings.settings.auto_refresh);
          setIsRealtimeEnabled(settings.settings.auto_refresh);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [DashboardClient] Failed to parse saved settings:', error);
      }
    }

    return () => {
      window.removeEventListener('refreshIntervalChanged', handleRefreshIntervalChange as EventListener);
    };
  }, []);


  // Effect for polling Fear & Greed Index
  useEffect(() => {
    const fearGreedInterval = setInterval(async () => {
      const data = await getRealtimeFearGreedIndex();
      if (data) setFearGreedIndex(data.indexValue);
    }, 5 * 60 * 1000);

    return () => {
      clearInterval(fearGreedInterval);
    };
  }, []);

  // üöÄ Ïã§ÏãúÍ∞Ñ Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (ÎèôÏ†Å Í∞ÑÍ≤©)
  useEffect(() => {
    if (!ticker || !isRealtimeEnabled || !autoRefreshEnabled) {
      console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} ÏóÖÎç∞Ïù¥Ìä∏ ÎπÑÌôúÏÑ±Ìôî - Realtime: ${isRealtimeEnabled}, Auto refresh: ${autoRefreshEnabled}`);
      return;
    }
    
    console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë (${refreshInterval}Ï¥à Í∞ÑÍ≤©)`);
    
    const stockDataInterval = setInterval(async () => {
      try {
        // ÌòÑÏû¨ Î°úÎî© Ï§ëÏù¥Í±∞ÎÇò Î∂ÑÏÑù Ï§ëÏù∏ Í≤ΩÏö∞ Ïä§ÌÇµ
        if (loading || loadingAnalysis || loadingSentiment) {
          console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} Îã§Î•∏ ÏûëÏóÖ ÏßÑÌñâ Ï§ë, Ïä§ÌÇµ`);
          return;
        }
        
        console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} üîÑ Îç∞Ïù¥ÌÑ∞ Í∞±Ïã† Ï§ë... (${refreshInterval}Ï¥à Í∞ÑÍ≤©)`);
        const result = await getStockAndChartData(ticker);
        
        if (result.stockData) {
          const updateTime = new Date();
          
          console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} ‚úÖ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å:`, {
            ÏãúÍ∞Ñ: updateTime.toLocaleTimeString('ko-KR'),
            Í∞ÄÍ≤©: result.stockData.currentPrice,
            Îì±ÎùΩÎ•†: `${result.stockData.dailyChange.percentage}%`,
            Î≥ºÎ•®: result.stockData.volume,
            Í∞ÑÍ≤©: `${refreshInterval}Ï¥à`
          });
          
          setStockData(result.stockData);
          setChartData(result.chartData as ChartData || []);
          setLastUpdateTime(updateTime);
        }
      } catch (error) {
        console.warn(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} ‚ö†Ô∏è ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:`, error);
        // Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®Îäî Î¨¥Ïãú (Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ)
      }
    }, refreshInterval * 1000); // ÎèôÏ†Å Í∞ÑÍ≤© Ï†ÅÏö©

    return () => {
      console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ`);
      clearInterval(stockDataInterval);
    };
  }, [ticker, isRealtimeEnabled, autoRefreshEnabled, refreshInterval, loading, loadingAnalysis, loadingSentiment]);

  // Effect to fetch data when ticker or language changes
  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
      return;
    }
  
    const abortController = new AbortController();
    let isMounted = true;
  
    const fetchTickerData = async (currentTicker: string) => {
      if (!isMounted || abortController.signal.aborted) return;
      
      setLoading(true);
      setError(null);
      setLoadingAnalysis(false);
      setLoadingSentiment(false);
      setLoadingNews(true);
      setAiAnalysis(null);
      setNewsSentiment(null);
      setAnalysisStarted(false);
  
      try {
        const analysisTicker = currentTicker === 'TSLL' ? 'TSLA' : currentTicker;
  
                // üöÄ Ï£ºÏãù Îç∞Ïù¥ÌÑ∞Î•º Î®ºÏ†Ä Îπ†Î•¥Í≤å Î°úÎìú
        console.log(`üìä [DashboardClient] ${currentTicker} Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠ ÏãúÏûë...`);
        const stockPromise = getStockAndChartData(currentTicker);
        
        // üóûÔ∏è Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞Îäî Î≥ëÎ†¨Î°ú ÏöîÏ≤≠ÌïòÎêò Í∞úÎ≥Ñ ÌÉÄÏûÑÏïÑÏõÉ Ï†ÅÏö©
        console.log(`üì∞ [DashboardClient] ${analysisTicker} Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠ ÏãúÏûë...`);
        const newsPromise = Promise.allSettled([
          Promise.race([
            getStockSpecificNews(analysisTicker, language),
            new Promise<NewsArticle[]>((_, reject) => 
              setTimeout(() => reject(new Error('Stock news timeout')), 45000)
            )
          ]),
          Promise.race([
            getMarketNews(language),
            new Promise<NewsArticle[]>((_, reject) => 
              setTimeout(() => reject(new Error('Market news timeout')), 25000)
            )
          ])
        ]);

        // Ï£ºÏãù Îç∞Ïù¥ÌÑ∞Îäî Îπ†Î•∏ ÌÉÄÏûÑÏïÑÏõÉÏúºÎ°ú Ï≤òÎ¶¨
        const crawledResult = await Promise.race([
          stockPromise,
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Stock data timed out after 15 seconds.')), 15000)
          )
        ]) as { stockData: StockData | null, chartData: ChartDataPoint[] };

        // Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞Îäî ÎπÑÎèôÍ∏∞Î°ú Ï≤òÎ¶¨
        const newsResults = await newsPromise;
        const stockArticles = newsResults[0].status === 'fulfilled' ? newsResults[0].value : [];
        const marketArticles = newsResults[1].status === 'fulfilled' ? newsResults[1].value : [];
        
        if (newsResults[0].status === 'rejected') {
          console.warn(`üì∞ [DashboardClient] Ï¢ÖÎ™© Îâ¥Ïä§ Î°úÎìú Ïã§Ìå®:`, newsResults[0].reason);
        }
        if (newsResults[1].status === 'rejected') {
          console.warn(`üìà [DashboardClient] ÏãúÏû• Îâ¥Ïä§ Î°úÎìú Ïã§Ìå®:`, newsResults[1].reason);
        }
  
        if (!isMounted || abortController.signal.aborted) return;
  
        if (!crawledResult.stockData) {
          throw new Error(`An error occurred while fetching data for ${currentTicker}. Please try again later.`);
        }
  
        setStockData(crawledResult.stockData);
        setChartData(crawledResult.chartData as ChartData || []);
        setNewsData(stockArticles || []);
        setMarketNews(marketArticles || []);
        
      } catch (err) {
        if (!isMounted || abortController.signal.aborted) return;
        
        console.error(`Failed to fetch data for ticker ${currentTicker}:`, err);
        const errorMessage = err instanceof Error ? err.message : 'An error occurred while loading data.';
        setError(errorMessage);
        const mockKey = currentTicker.toUpperCase();
        setStockData(mockStockData[mockKey] || mockStockData['AAPL']);
        setChartData(mockChartData[mockKey] || mockChartData['AAPL']);
        setNewsData(mockNewsData[mockKey] || mockNewsData['DEFAULT']);
      } finally {
        if (isMounted && !abortController.signal.aborted) {
          setLoading(false);
          setLoadingNews(false);
        }
      }
    };
  
    if (ticker) {
      fetchTickerData(ticker);
    }
  
    return () => {
      isMounted = false;
      abortController.abort();
    };
  }, [ticker, language]);

  const handleStartAnalysis = async () => {
    if (!stockData || chartData.length === 0 || newsData.length === 0) {
      setError("Cannot start analysis without stock data, chart data, and news.");
      return;
    }
  
    setAnalysisStarted(true);
    setLoadingAnalysis(true);
    setLoadingSentiment(true);
  
    try {
      const articleTitles = newsData.map(n => n.title);
      const sentimentData = await getNewsSentiment(articleTitles, language);
      setNewsSentiment(sentimentData);
      setLoadingSentiment(false);
      
      const analysisData = await getAiAnalysis(
        stockData, 
        chartData, 
        sentimentData, 
        language,
        user?.id,
        [...newsData, ...marketNews],
        marketNews
      );
      setAiAnalysis(analysisData);
      setLoadingAnalysis(false);

    } catch (error) {
        console.error("Error fetching analysis or sentiment:", error);
        const errorReason = error instanceof Error ? error.message : "Unknown error";
        const errorMessage = language === 'kr' ? `AI Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${errorReason}` : `An error occurred during AI analysis: ${errorReason}`;
        
        setAiAnalysis({ analysisSummary: errorMessage, recommendation: 'Hold', confidenceScore: 0 });
        setNewsSentiment({ sentiment: 'neutral', confidenceScore: 0, reasoning: errorMessage });
        
        setLoadingAnalysis(false);
        setLoadingSentiment(false);
    }
  };

  const handleSelectTicker = (newTicker: string) => {
    if (newTicker && newTicker.toUpperCase() !== ticker) {
      setTicker(newTicker.toUpperCase());
    }
  };

  const handleToggleRealtime = () => {
    setIsRealtimeEnabled(!isRealtimeEnabled);
    console.log(`[Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏] ${ticker} Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ${!isRealtimeEnabled ? 'ÌôúÏÑ±Ìôî' : 'ÎπÑÌôúÏÑ±Ìôî'}`);
  };

  // Î°úÎî© Ïä§ÌÅ¨Î¶∞ ÌëúÏãú
  if (isAppLoading) {
    return <LoadingScreen onLoaded={() => setIsAppLoading(false)} />;
  }

  return (
    <div className="flex min-h-screen w-full flex-col bg-background">
      <Header />
      <main className="flex flex-1 flex-col gap-4 p-4 md:gap-8 md:p-8">
        <div className="flex flex-col gap-4">
          <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
            <StockSearch onSelectTicker={handleSelectTicker} currentTicker={ticker} />
          </div>
          
          {/* Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏÉÅÌÉú ÌëúÏãú */}
          <RealtimeStatus 
            isEnabled={isRealtimeEnabled}
            lastUpdateTime={lastUpdateTime}
            onToggle={handleToggleRealtime}
            ticker={ticker}
          />
        </div>
        
        {/* Global Indices Card */}
        <GlobalIndices />
        
        {error && (
            <Alert variant="destructive">
              <Terminal className="h-4 w-4" />
              <AlertTitle>Data Loading Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

        <div className="grid gap-4 md:grid-cols-2 md:gap-8 lg:grid-cols-3">
          <div className="grid auto-rows-max items-start gap-4 md:gap-8 lg:col-span-2">
            <div className="grid gap-4 sm:grid-cols-1 md:grid-cols-1">
              {loading || chartData.length === 0 ? <Skeleton className="h-[450px] w-full" /> : <FinancialChart data={chartData} />}
            </div>
            {loading || !stockData ? <Skeleton className="h-[200px] w-full" /> : <StockDataTable data={stockData} />}
            {/* üì∞ ÏµúÏã† Îâ¥Ïä§ Ïπ¥ÎìúÎ•º Í∞ÄÍ≤©/Î≥ºÎ•® Ï†ïÎ≥¥ ÏïÑÎûòÎ°ú Ïù¥Îèô */}
            <NewsCards news={newsData} marketNews={marketNews} loading={loadingNews} stockData={stockData} />
          </div>
          <div className="grid auto-rows-max items-start gap-4 md:gap-8">
            <Suspense fallback={<Skeleton className="h-[250px] w-full" />}>
              <AiAnalysis 
                analysis={aiAnalysis} 
                sentiment={newsSentiment} 
                loading={loadingAnalysis || loadingSentiment} 
                analysisStarted={analysisStarted}
                onStartAnalysis={handleStartAnalysis}
                stockData={stockData}
                language={language}
                allNews={[...newsData, ...marketNews]}
                stockNewsData={newsData}
                marketNewsData={marketNews}
                chartTrend={(stockData?.dailyChange?.percentage || 0) > 0 ? 'uptrend' : (stockData?.dailyChange?.percentage || 0) < 0 ? 'downtrend' : 'sideways'}
              />
            </Suspense>
            {/* üìÖ ÏùºÏ†ï + üí¨ ÏõîÍ∞ÄÏùò ÎßêÎßêÎßê ÏÇ¨Ïù¥ÎìúÎ∞î Ï∂îÍ∞Ä */}
            <SidebarInfo marketNews={marketNews} />
          </div>
        </div>
        
        {/* üî• Í≥µÌè¨ & ÌÉêÏöï ÏßÄÏàòÎ•º Îß® ÏïÑÎûò Ï†ÑÏ≤¥ Ìè≠ÏúºÎ°ú Î∞∞Ïπò */}
        <div className="w-full">
          <FearGreedIndex value={fearGreedIndex} loading={fearGreedIndex === null}/>
        </div>
      </main>
    </div>
  );
}
